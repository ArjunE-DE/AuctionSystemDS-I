import socket
import struct
import threading
import json
import random
import time
from datetime import datetime

# ------------------------------
# Configuration
# ------------------------------
MCAST_GRP = "224.1.1.1"
MCAST_PORT = 5000
SERVER_PORT = random.randint(5001, 5010)
SERVER_ID = random.randint(1000, 9999)

STATE = {"items": []}
LEADER = None
KNOWN_SERVERS = {}       # port -> server_id
LAST_HEARTBEAT = {}      # port -> timestamp

# HS election state
HS_ACTIVE = False
HS_PHASE = 0
HS_REPLIES = set()
HS_RING = []
ELECTION_EPOCH = 0
HS_LOCK = threading.Lock()

# Membership stability
STABLE_DELAY = 1  # seconds
last_membership_change = time.time()

# Timing
DISCOVERY_INTERVAL = 1
HEARTBEAT_INTERVAL = 2
HEARTBEAT_TIMEOUT = 6
STATUS_INTERVAL = 10
STARTUP_WAIT = 2  # seconds to wait for leader discovery

# ------------------------------
# UDP sockets
# ------------------------------
server_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_sock.bind(("0.0.0.0", SERVER_PORT))

mcast_sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
mcast_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
mcast_sock.bind(("", MCAST_PORT))
mreq = struct.pack("4sl", socket.inet_aton(MCAST_GRP), socket.INADDR_ANY)
mcast_sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)

print(f"[{SERVER_PORT}] üöÄ Server started | ID={SERVER_ID}")

# ------------------------------
# Utilities
# ------------------------------
def send_to_multicast(msg):
    mcast_sock.sendto(msg.encode(), (MCAST_GRP, MCAST_PORT))

def send_to_server(port, msg):
    try:
        server_sock.sendto(msg.encode(), ("127.0.0.1", port))
    except Exception as e:
        print(f"[{SERVER_PORT}] ‚ö†Ô∏è Failed to send to {port}: {e}")

def send_hello():
    send_to_multicast(json.dumps({
        "type": "HELLO",
        "server_port": SERVER_PORT,
        "server_id": SERVER_ID
    }))

def send_server_snapshot(to_port):
    msg = {
        "type": "SERVER_SNAPSHOT",
        "leader": LEADER,
        "servers": KNOWN_SERVERS  # {port: server_id}
    }
    send_to_server(to_port, json.dumps(msg))

# ------------------------------
# Ring helpers for HS
# ------------------------------
def compute_ring():
    if len(KNOWN_SERVERS) == 0:
        return [(SERVER_PORT, SERVER_ID)]
    return sorted(KNOWN_SERVERS.items(), key=lambda x: x[1])

def ring_neighbors(ring=None):
    ring = ring or HS_RING
    if len(ring) == 1:
        return SERVER_PORT, SERVER_PORT
    ids = [sid for _, sid in ring]
    idx = ids.index(SERVER_ID)
    left = ring[(idx - 1) % len(ring)][0]
    right = ring[(idx + 1) % len(ring)][0]
    return left, right

# ------------------------------
# Hirschberg‚ÄìSinclair Election
# ------------------------------
def maybe_start_hs():
    global last_membership_change
    if HS_ACTIVE or len(KNOWN_SERVERS) == 0:
        return
    if LEADER is not None:
        return
    if time.time() - last_membership_change < STABLE_DELAY:
        return
    # Start HS election if smallest ID
    smallest = min(KNOWN_SERVERS.values())
    if SERVER_ID == smallest:
        start_hs_election()

def start_hs_election():
    global HS_ACTIVE, HS_PHASE, HS_REPLIES, HS_RING, ELECTION_EPOCH
    with HS_LOCK:
        if HS_ACTIVE:
            return
        HS_ACTIVE = True
        HS_PHASE = 0
        HS_REPLIES.clear()
        ELECTION_EPOCH += 1
        HS_RING = compute_ring()
        if len(HS_RING) == 1:
            elect_self()
            return
        print(f"[{SERVER_PORT}] üîÅ HS START | epoch={ELECTION_EPOCH} | Ring={[sid for _, sid in HS_RING]}")
        send_hs_messages()

def send_hs_messages():
    global HS_PHASE
    left, right = ring_neighbors()
    hops = 2 ** HS_PHASE
    base = {
        "type": "ELECTION",
        "candidate": SERVER_ID,
        "phase": HS_PHASE,
        "hops": hops,
        "epoch": ELECTION_EPOCH,
        "hop_count": 0
    }
    print(f"[{SERVER_PORT}] üì§ HS phase={HS_PHASE} hops={hops} LEFT={left} RIGHT={right}")
    send_to_server(left, json.dumps({**base, "direction": "LEFT"}))
    send_to_server(right, json.dumps({**base, "direction": "RIGHT"}))

def handle_election(msg):
    global HS_PHASE, HS_REPLIES
    if msg["epoch"] != ELECTION_EPOCH:
        return
    cand = msg["candidate"]
    hops = msg["hops"]
    direction = msg["direction"]
    hop_count = msg.get("hop_count", 0)
    print(f"[{SERVER_PORT}] üì• ELECTION cand={cand} hops={hops} hop_count={hop_count}")
    if cand < SERVER_ID:
        print(f"[{SERVER_PORT}] ‚ùå Suppress smaller ID {cand}")
        return
    if cand > SERVER_ID:
        if hops > 1:
            msg["hops"] -= 1
            msg["hop_count"] += 1
            forward(msg)
        else:
            send_reply(msg)
        return
    # Candidate is self
    HS_REPLIES.add(direction)
    print(f"[{SERVER_PORT}] üîÑ Own ID returned from {direction}")
    if HS_REPLIES == {"LEFT", "RIGHT"}:
        HS_REPLIES.clear()
        HS_PHASE += 1
        send_hs_messages()

def handle_reply(msg):
    global LEADER, HS_ACTIVE
    if msg["epoch"] != ELECTION_EPOCH:
        return
    if msg["candidate"] != SERVER_ID:
        forward(msg)
        return
    direction = msg["direction"]
    HS_REPLIES.add(direction)
    print(f"[{SERVER_PORT}] üì¨ REPLY from {direction}")
    if HS_REPLIES == {"LEFT", "RIGHT"}:
        LEADER = SERVER_ID
        HS_ACTIVE = False
        print(f"[{SERVER_PORT}] üëë I AM LEADER")
        broadcast_leader()

def send_reply(msg):
    reply = {
        "type": "REPLY",
        "candidate": msg["candidate"],
        "direction": "LEFT" if msg["direction"] == "RIGHT" else "RIGHT",
        "epoch": msg["epoch"],
        "hop_count": msg.get("hop_count", 0) + 1
    }
    forward(reply)

def forward(msg):
    left, right = ring_neighbors()
    target = left if msg["direction"] == "LEFT" else right
    send_to_server(target, json.dumps(msg))

def broadcast_leader():
    msg = {"type": "LEADER", "leader": SERVER_ID}
    for port in KNOWN_SERVERS:
        if port != SERVER_PORT:
            send_to_server(port, json.dumps(msg))
            send_server_snapshot(port)

def elect_self():
    global LEADER, HS_ACTIVE
    LEADER = SERVER_ID
    HS_ACTIVE = False
    print(f"[{SERVER_PORT}] üëë SINGLE NODE LEADER")
    broadcast_leader()

# ------------------------------
# Multicast discovery
# ------------------------------
def multicast_listener():
    global last_membership_change
    while True:
        try:
            data, _ = mcast_sock.recvfrom(1024)
            msg = json.loads(data.decode())
        except:
            continue
        if msg.get("type") != "HELLO":
            continue
        port = msg["server_port"]
        sid = msg["server_id"]
        if port == SERVER_PORT:
            continue
        is_new = port not in KNOWN_SERVERS
        KNOWN_SERVERS[port] = sid
        LAST_HEARTBEAT[port] = time.time()
        if is_new:
            last_membership_change = time.time()
            print(f"[{SERVER_PORT}] ‚ûï New server joined ({sid})")
            if LEADER is not None:
                print(f"[{SERVER_PORT}] üì° Sending leader info and snapshot to new node {sid}")
                send_to_server(port, json.dumps({"type":"LEADER","leader":LEADER}))
                send_server_snapshot(port)

# ------------------------------
# Leader monitor
# ------------------------------
def leader_monitor():
    global LEADER
    while True:
        if LEADER and LEADER != SERVER_ID:
            leader_port = next((p for p, sid in KNOWN_SERVERS.items() if sid == LEADER), None)
            if not leader_port or time.time() - LAST_HEARTBEAT.get(leader_port, 0) > HEARTBEAT_TIMEOUT:
                print(f"[{SERVER_PORT}] üíÄ Leader dead ‚Üí restart HS")
                LEADER = None
                maybe_start_hs()
        time.sleep(HEARTBEAT_INTERVAL)

# ------------------------------
# Server listener
# ------------------------------
def server_listener():
    global LEADER
    while True:
        try:
            data, addr = server_sock.recvfrom(4096)
            msg = json.loads(data.decode())
        except:
            continue
        if msg["type"] == "ELECTION":
            handle_election(msg)
        elif msg["type"] == "REPLY":
            handle_reply(msg)
        elif msg["type"] == "LEADER":
            incoming_leader = msg["leader"]
            if LEADER is None:
                LEADER = incoming_leader
                print(f"[{SERVER_PORT}] üëë Leader declaration received: {incoming_leader} ‚Üí accepted")
            elif LEADER != incoming_leader:
                print(f"[{SERVER_PORT}] üëë Leader declaration received: {incoming_leader} ‚Üí rejected (already have {LEADER})")
            else:
                print(f"[{SERVER_PORT}] üëë Leader declaration received: {incoming_leader} ‚Üí already set")
        elif msg["type"] == "SERVER_SNAPSHOT":
            incoming_leader = msg.get("leader")
            snapshot = msg.get("servers", {})
            if LEADER is None:
                LEADER = incoming_leader
                print(f"[{SERVER_PORT}] üëë Leader adopted from snapshot: {LEADER}")
            else:
                print(f"[{SERVER_PORT}] üëë Leader in snapshot: {incoming_leader} | Current: {LEADER}")
            for port, sid in snapshot.items():
                if int(port) not in KNOWN_SERVERS:
                    KNOWN_SERVERS[int(port)] = sid
                    LAST_HEARTBEAT[int(port)] = time.time()
                    print(f"[{SERVER_PORT}] üóÇ Added server from snapshot: {sid} on port {port}")

# ------------------------------
# Periodic hello
# ------------------------------
def periodic_hello():
    while True:
        send_hello()
        time.sleep(DISCOVERY_INTERVAL)

# ------------------------------
# Status printer
# ------------------------------
def print_status():
    while True:
        print(f"\n[{SERVER_PORT}] STATUS")
        print(f"ID={SERVER_ID} | Leader={LEADER}")
        print(f"Known={list(KNOWN_SERVERS.values())}")
        time.sleep(STATUS_INTERVAL)

# ------------------------------
# Main
# ------------------------------
if __name__ == "__main__":
    KNOWN_SERVERS[SERVER_PORT] = SERVER_ID
    LAST_HEARTBEAT[SERVER_PORT] = time.time()

    # Start listeners first
    threading.Thread(target=multicast_listener, daemon=True).start()
    threading.Thread(target=server_listener, daemon=True).start()
    threading.Thread(target=periodic_hello, daemon=True).start()
    threading.Thread(target=leader_monitor, daemon=True).start()
    threading.Thread(target=print_status, daemon=True).start()

    # Wait for leader discovery
    print(f"[{SERVER_PORT}] ‚è≥ Waiting {STARTUP_WAIT}s for leader discovery...")
    start = time.time()
    while time.time() - start < STARTUP_WAIT:
        time.sleep(0.1)
        if LEADER is not None:
            print(f"[{SERVER_PORT}] üëë Leader detected during startup: {LEADER}")
            break

    if LEADER is None:
        print(f"[{SERVER_PORT}] ‚ö° No leader found ‚Üí triggering HS election")
        maybe_start_hs()

    while True:
        time.sleep(1)
